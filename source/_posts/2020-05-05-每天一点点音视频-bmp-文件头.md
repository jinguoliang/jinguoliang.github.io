---
title: 每天一点点音视频_bmp_文件头
date: 2020-05-05 09:13:41
tags:
- 音视频
- bmp
- 文件格式
categories:
- 编程
---

## 文件头

BMP文件头在 BMP 文件的开始，用来识别该文件。典型的应用会读取首先这部分数据来确定这个文件是 BMP 格式， 并确定没有破坏。开头两个字节是 ASCII 码的 “BM”。所有整型值都是小端的，即低位数据在前。

偏移（16进制） | 偏移（10进制） | 大小 | 作用
-|-|-|-
00 | 0 | 2 bytes | BM, 在 OS/2 系统还可以是其他值，但可以不考虑了
02 | 2 | 4 bytes | BMP 文件的大小
06 | 6 | 2 bytes | 保留，创建 BMP 的应用可以自己定义它的作用
08 | 8 | 2 bytes | 保留，创建 BMP 的应用可以自己定义它的作用
0A | 10 | 4 bytes | 图像数据的偏移（像素点的数据）

我用 kotlin 写了个读取这一部分的功能：

{% codeblock lang:kotlin %}
File("/sdcard/test.bmp").also {
    val reader = it.reader()
    val charArray = CharArray(4)
    reader.read(charArray, 0, 2)
    Log.e(TAG, "id: ${charArray[0]}${charArray[1]}")
    reader.read(charArray, 0, 4)
    Log.e(
        TAG,
        "file size: ${charArray[3].toInt() * pow(16.0, 3.0)
                + charArray[2].toInt() * pow(16.0, 2.0) 
                + charArray[1].toInt() * 16.0 
                + charArray[0].toDouble()}"
    )
    Log.e(TAG, "file size: ${it.length() / 8}")
    reader.read(charArray, 0, 2)
    Log.e(TAG, "reserved: ${charArray[1].toInt() * 16.0
            + charArray[0].toDouble()}")
    reader.read(charArray, 0, 2)
    Log.e(TAG, "reserved: ${charArray[1].toInt() * 16.0
            + charArray[0].toDouble()}")
    reader.read(charArray, 0, 4)
    Log.e(TAG, "offset: ${charArray[3].toInt() * pow(16.0, 3.0)
            + charArray[2].toInt() * pow(16.0, 2.0)
            + charArray[1].toInt() * 16.0
            + charArray[0].toDouble()}")
}
{% endcodeblock %}

读取的文件大小和直接用 File 读取的文件大小不一致，之后要研究一下。


明天： 每天一点点音视频_bmp_dip头